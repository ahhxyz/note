
# service

component复用的`功能`
# 模型
component复用的 `数据`


# 使用`setter()`和`getter()`

最大的好处就是，某个值发生了变化就会触发一个函数，进而执行自定义逻辑，超级有用

在指令中，将属性绑定到setter()，那么模型的属性值发生变化时就会触发这个setter()


# 守卫函数
* 执行顺序: `canLoad() canActivateChild()() canActivate() resolve()`


# 数据保持和共享

### 保持
指一个组件引用了一个导出变量，在组件中修改了该变量的值，销毁后重新实例化组件，依然能够读取到上次修改的值
但这些数据无需在其他组件使用或共享
### 组件间数据共享
* 如果导出变量是引用类型，那么赋值时不会发生值的拷贝，只是变量会指向新的内存地址。正因为如此，在一个组件中对导出变量进行赋值后，另一组件无法读取到新值，因为不同组件中导出变量指向的内存地址都是一样的，当一个组件A中给导出变量赋值时，导出变量会指向一个新的内存地址，它的值也正是在这个内存空间中，而组件B中导出变量还是指向之前的地址，所以读取不到新值。组件A重新实例化时，导出变量又指向了的初始的地址，那么组件A仍然读取不到导出变量的新值。
* 如果导出变量是基础数据类型，那么赋值时会发生值的拷贝且指向的地址始终不会改变，所以其他组件可以读取到新值


也可采用如下方法解决：

* 建立一个service,引入该导出变量
* service中增加一个静态属性，用来保存该导出变量
* 在构造函数中使用上面的静态属性维护一个导出变量的单例
* 新值针对该导出变量的setter()和getter()，都是通过操作上面的静态属性来实现的




